<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>B·∫£o T√†ng D√¢n T·ªôc 3D - 54 D√¢n T·ªôc Vi·ªát Nam</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
        }
        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        #instructions {
            background: rgba(20, 20, 30, 0.95);
            padding: 40px;
            text-align: center;
            color: #fff;
            border-radius: 15px;
            border: 2px solid #FFD700;
            max-width: 600px;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }
        #instructions h2 {
            margin-bottom: 20px;
            color: #FFD700;
            font-size: 2.5em;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        #instructions p {
            font-size: 1.1em;
            margin-bottom: 20px;
            line-height: 1.6;
            color: #ddd;
        }
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 25px 0;
            text-align: left;
        }
        .controls-grid div {
            padding: 15px;
            background: rgba(255, 215, 0, 0.1);
            border-left: 3px solid #FFD700;
            border-radius: 5px;
        }
        .controls-grid strong {
            display: block;
            margin-bottom: 8px;
            color: #FFD700;
        }
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }
        button {
            padding: 12px 30px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            transition: all 0.3s;
            min-width: 160px;
        }
        #start-button {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }
        #start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }
        #back-button {
            background: linear-gradient(135deg, #FF6B6B, #FF4757);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }
        #back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
        }
        #status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 20px;
            font-size: 0.9em;
            z-index: 50;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            border-top: 2px solid #FFD700;
        }
        #room-indicator {
            font-weight: bold;
            font-size: 1.1em;
            color: #FFD700;
            min-width: 100px;
        }
        #navigation-hint {
            flex: 1;
            color: #aaa;
            font-size: 0.9em;
        }
        #room-dots {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        .room-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        .room-dot:hover {
            transform: scale(1.3);
        }
        .room-dot.active {
            background: #FFD700 !important;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
            border-color: #FFD700;
        }
        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px;
            max-height: 80vh;
            background: rgba(15, 15, 25, 0.98);
            color: white;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #FFD700;
            display: none;
            flex-direction: column;
            z-index: 20;
            overflow: hidden;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.2);
        }
        #info-panel h3 {
            margin-top: 0;
            font-size: 1.3em;
            color: #FFD700;
            border-bottom: 2px solid #FFD700;
            padding-bottom: 10px;
            margin-bottom: 12px;
            flex-shrink: 0;
        }
        #info-panel p {
            line-height: 1.4;
            margin-bottom: 10px;
            text-align: justify;
            font-size: 0.85em;
            color: #ddd;
            flex: 1;
            overflow-y: auto;
            padding-right: 8px;
        }
        #info-panel p::-webkit-scrollbar {
            width: 6px;
        }
        #info-panel p::-webkit-scrollbar-track {
            background: rgba(255, 215, 0, 0.1);
            border-radius: 3px;
        }
        #info-panel p::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.5);
            border-radius: 3px;
        }
        #info-panel p::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 215, 0, 0.8);
        }
        #scroll-hint {
            text-align: center;
            font-size: 0.75em;
            color: rgba(255, 215, 0, 0.6);
            margin-top: 8px;
            animation: blink 1.5s infinite;
            display: none;
        }
        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0.5; }
        }
        #close-info-button {
            margin-top: 12px;
            padding: 10px;
            background: linear-gradient(135deg, #FF6B6B, #FF4757);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            flex-shrink: 0;
            width: 100%;
            font-size: 0.9em;
        }
        #close-info-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
        }
        #sidebar {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            max-height: 75vh;
            background: rgba(15, 15, 25, 0.98);
            color: white;
            padding: 15px;
            border-radius: 12px;
            border: 2px solid #FFD700;
            overflow-y: auto;
            z-index: 20;
            display: none;
            flex-direction: column;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.2);
        }
        #sidebar h3 {
            margin: 0 0 10px 0;
            color: #FFD700;
            font-size: 1.1em;
            border-bottom: 2px solid #FFD700;
            padding-bottom: 10px;
        }
        #ethnic-list {
            font-size: 0.85em;
            line-height: 1.8;
        }
        .ethnic-item {
            padding: 6px 8px;
            margin: 3px 0;
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ethnic-item:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        #toggle-sidebar-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #FFD700;
            color: #000;
            border: none;
            cursor: pointer;
            font-size: 1.3em;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
            z-index: 30;
            transition: all 0.3s;
        }
        #toggle-sidebar-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.6);
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-top: -10px;
            margin-left: -10px;
            pointer-events: none;
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-radius: 50%;
            z-index: 9;
            box-shadow: 0 0 5px rgba(255, 215, 0, 0.4);
        }
    </style>
</head>
<body>
    <div id="blocker">
        <div id="instructions">
            <h2>üèõÔ∏è B·∫¢O T√ÄNG D√ÇN T·ªòC 3D</h2>
            <p>Kh√°m ph√° n·ªÅn vƒÉn h√≥a phong ph√∫ c·ªßa 54 d√¢n t·ªôc Vi·ªát Nam</p>
            <div class="controls-grid">
                <div>
                    <strong>‚å®Ô∏è Di chuy·ªÉn:</strong>
                    W/‚Üë Ti·∫øn | S/‚Üì L√πi<br>A/‚Üê Tr√°i | D/‚Üí Ph·∫£i
                </div>
                <div>
                    <strong>üñ±Ô∏è T∆∞∆°ng t√°c:</strong>
                    Click xem th√¥ng tin<br>E ƒë√≥ng | L danh s√°ch | F tho√°t
                </div>
            </div>
            <div class="button-group">
                <button id="start-button">üéÆ B·∫Øt ƒê·∫ßu</button>
                <button id="back-button">üè† Quay L·∫°i</button>
            </div>
        </div>
    </div>

    <div id="crosshair"></div>

    <div id="status-bar">
        <span id="room-indicator">Ph√≤ng: 1/3</span>
        <span id="navigation-hint">W/A/S/D di chuy·ªÉn ‚Ä¢ Click xem ‚Ä¢ E ƒë√≥ng ‚Ä¢ L danh s√°ch ‚Ä¢ F tho√°t</span>
        <div id="room-dots">
            <span class="room-dot active" data-room="1" style="background: #FFD700;"></span>
            <span class="room-dot" data-room="2" style="background: #888;"></span>
            <span class="room-dot" data-room="3" style="background: #888;"></span>
        </div>
    </div>

    <div id="info-panel">
        <h3 id="art-title">T√™n d√¢n t·ªôc</h3>
        <p id="art-description">Th√¥ng tin chi ti·∫øt v·ªÅ d√¢n t·ªôc...</p>
        <div id="scroll-hint">‚¨áÔ∏è Cu·ªôn ƒë·ªÉ xem th√™m (‚Üë‚Üì ho·∫∑c chu·ªôt)</div>
        <button id="close-info-button">‚úï ƒê√≥ng (E)</button>
    </div>

    <div id="sidebar">
        <h3>üìã 54 D√¢n T·ªôc</h3>
        <div id="ethnic-list"></div>
    </div>

    <button id="toggle-sidebar-btn">üìã</button>

    <script>
        // ===== C·∫§U H√åNH 3 PH√íNG =====
        const ROOM_WIDTH = 20;
        const ROOM_HEIGHT = 8;
        const ROOM_DEPTH = 16;
        const DOOR_WIDTH = 3;        // Width of door opening
        const DOOR_HEIGHT = 3.5;     // Height of door opening
        const DOOR_BOTTOM_Y = 1.0;   // Door starts at this height

        // Optimized spacing: 18 units between room centers (better proportions)
        const ROOM_CENTERS = [0, 18, 36];

        // Door positions: centered between rooms
        const DOOR_CENTER_X1 = 9;    // Between Room 1 (0) and Room 2 (18)
        const DOOR_CENTER_X2 = 27;   // Between Room 2 (18) and Room 3 (36)

        // Room bounds (excluding door areas)
        const ROOM_BOUNDS = [
            { minX: -10.5, maxX: 7.5 },   // Room 1: left side only
            { minX: 10.5, maxX: 25.5 },   // Room 2: middle (door gaps at 9 and 27)
            { minX: 28.5, maxX: 46.5 }    // Room 3: right side only
        ];

        // Door passage areas (allow free movement through doors)
        const DOOR_ZONES = [
            { x: DOOR_CENTER_X1, minZ: -1.5, maxZ: 1.5 },  // Door 1 zone
            { x: DOOR_CENTER_X2, minZ: -1.5, maxZ: 1.5 }   // Door 2 zone
        ];

        const Z_BOUNDS = { min: -8, max: 8 };

        // ===== BI·∫æN TO√ÄN C·ª§C =====
        let scene, camera, renderer, controls, raycaster;
        let moveState = { forward: false, backward: false, left: false, right: false };
        const clock = new THREE.Clock();
        const objects = [];
        const artworks = [];
        let currentRoom = 1;
        let activeArtMesh = null;
        let isControlsLocked = false;
        let ethnicData = [];
        let skyTexture = null;  // Global variable for sky texture

        init();
        animate();

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 80, 100);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFShadowShadowMap;
            document.body.appendChild(renderer.domElement);

            // Ambient lighting - increased brightness
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
            scene.add(ambientLight);

            // Directional light with shadow - increased brightness
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(30, 20, 30);
            dirLight.castShadow = true;
            dirLight.shadow.camera.far = 100;
            dirLight.shadow.camera.left = -60;
            dirLight.shadow.camera.right = 60;
            dirLight.shadow.camera.top = 40;
            dirLight.shadow.camera.bottom = -40;
            scene.add(dirLight);

            // Load ethnic data
            try {
                const response = await fetch('/mln131/ethnicMuseum.json');
                ethnicData = await response.json();
                console.log(`‚úì Loaded ${ethnicData.length} ethnic groups`);
            } catch (e) {
                console.error('Error loading data:', e);
                ethnicData = [];
            }

            // Load textures
            const textureLoader = new THREE.TextureLoader();
            let wallTexture = null;

            try {
                wallTexture = await new Promise((resolve, reject) => {
                    textureLoader.load(
                        '/mln131/TSG_CG_0006_DARK_SHINY_3_DIFFUSE.jpg',
                        (texture) => {
                            texture.wrapS = THREE.RepeatWrapping;
                            texture.wrapT = THREE.RepeatWrapping;
                            texture.repeat.set(4, 4);
                            resolve(texture);
                        },
                        undefined,
                        reject
                    );
                });
                console.log('‚úì Wall texture loaded');
            } catch (e) {
                console.warn('Could not load wall texture:', e);
            }

            // Load sky texture for ceiling
            try {
                skyTexture = await new Promise((resolve, reject) => {
                    textureLoader.load(
                        '/mln131/sku.jpg',
                        (texture) => {
                            texture.wrapS = THREE.ClampToEdgeWrapping;
                            texture.wrapT = THREE.ClampToEdgeWrapping;
                            resolve(texture);
                        },
                        undefined,
                        reject
                    );
                });
                console.log('‚úì Sky texture loaded');
            } catch (e) {
                console.warn('Could not load sky texture:', e);
            }

            // Background color - brighter
            scene.background = new THREE.Color(0x555555);

            // Create SINGLE shared materials
            const wallMat = new THREE.MeshStandardMaterial({
                map: wallTexture,
                roughness: 0.6,
                metalness: 0.3,
                side: THREE.DoubleSide
            });

            const floorMat = new THREE.MeshStandardMaterial({
                map: wallTexture,
                roughness: 0.7,
                metalness: 0.2,
                side: THREE.DoubleSide
            });

            // Create 3 rooms using SAME materials
            // Room 1: solid left wall (right wall is shared door)
            createRoom(ROOM_CENTERS[0], wallMat, floorMat, 'left');

            // Room 2: no side walls (both left and right are shared doors)
            createRoom(ROOM_CENTERS[1], wallMat, floorMat, null);

            // Room 3: solid right wall (left wall is shared door)
            createRoom(ROOM_CENTERS[2], wallMat, floorMat, 'right');

            // Create SHARED door walls between rooms
            createWallWithDoor(DOOR_CENTER_X1, 0, 0, -Math.PI / 2, ROOM_DEPTH, ROOM_HEIGHT, DOOR_WIDTH, DOOR_HEIGHT, wallMat);
            createWallWithDoor(DOOR_CENTER_X2, 0, 0, -Math.PI / 2, ROOM_DEPTH, ROOM_HEIGHT, DOOR_WIDTH, DOOR_HEIGHT, wallMat);

            // Setup controls
            controls = new THREE.PointerLockControls(camera, renderer.domElement);
            scene.add(controls.getObject());
            controls.getObject().position.set(0, 1.6, 0);

            document.getElementById("start-button").addEventListener("click", () => controls.lock());
            document.getElementById("back-button").addEventListener("click", () => {
                window.location.href = "/mln131/";
            });

            controls.addEventListener("lock", () => {
                document.getElementById("blocker").style.display = "none";
                isControlsLocked = true;
            });
            controls.addEventListener("unlock", () => {
                document.getElementById("blocker").style.display = "flex";
                isControlsLocked = false;
            });

            document.addEventListener("keydown", onKeyDown);
            document.addEventListener("keyup", onKeyUp);

            // Room navigation dots
            document.querySelectorAll(".room-dot").forEach(dot => {
                dot.addEventListener("click", (e) => {
                    const roomNum = parseInt(e.target.dataset.room);
                    teleportToRoom(roomNum);
                });
            });

            // Sidebar & info panel
            document.getElementById("toggle-sidebar-btn").addEventListener("click", toggleSidebar);
            document.getElementById("close-info-button").addEventListener("click", closeInfoPanel);

            // Add scroll support for info-panel
            const infoPanelDescription = document.getElementById("art-description");

            // Mouse wheel scroll
            infoPanelDescription.addEventListener("wheel", (e) => {
                e.preventDefault();
                infoPanelDescription.scrollTop += e.deltaY;
            }, { passive: false });

            // Touch scroll support (for mobile)
            let touchStartY = 0;
            infoPanelDescription.addEventListener("touchstart", (e) => {
                touchStartY = e.touches[0].clientY;
            });
            infoPanelDescription.addEventListener("touchmove", (e) => {
                const touchEndY = e.touches[0].clientY;
                const diff = touchStartY - touchEndY;
                infoPanelDescription.scrollTop += diff;
                touchStartY = touchEndY;
            });

            // Keyboard scroll (arrow up/down when info-panel is visible)
            document.addEventListener("keydown", (e) => {
                const infoPanelVisible = document.getElementById("info-panel").style.display === "flex";
                if (infoPanelVisible) {
                    if (e.code === "ArrowDown") {
                        e.preventDefault();
                        infoPanelDescription.scrollTop += 30;
                    } else if (e.code === "ArrowUp") {
                        e.preventDefault();
                        infoPanelDescription.scrollTop -= 30;
                    }
                }
            });

            document.addEventListener("keydown", (e) => {
                if (e.code === "KeyL" && isControlsLocked) {
                    e.preventDefault();
                    toggleSidebar();
                }
                if (e.code === "KeyE") {
                    e.preventDefault();
                    closeInfoPanel();
                }
                if (e.code === "KeyF") {
                    e.preventDefault();
                    window.location.href = "/mln131/";
                }
            });

            raycaster = new THREE.Raycaster();
            document.addEventListener("click", (event) => {
                if (isControlsLocked) onClick(event);
            });

            populateEthnicList();
            addAllArtworks();
            window.addEventListener("resize", onWindowResize);
        }

        // ===== T·∫†O T∆Ø·ªúNG C√ì C·ª¨A =====
        function createWallWithDoor(x, y, z, rotationY, width, height, dWidth, dHeight, wallMat, thickness = 0.5) {
            const group = new THREE.Group();

            // B√™n tr√°i c·ª≠a
            const left = new THREE.Mesh(new THREE.BoxGeometry((width - dWidth) / 2, height, thickness), wallMat);
            left.position.set(-(dWidth / 2 + (width - dWidth) / 4), height / 2, 0);
            left.castShadow = true;
            left.receiveShadow = true;
            group.add(left);

            // B√™n ph·∫£i c·ª≠a
            const right = new THREE.Mesh(new THREE.BoxGeometry((width - dWidth) / 2, height, thickness), wallMat);
            right.position.set(dWidth / 2 + (width - dWidth) / 4, height / 2, 0);
            right.castShadow = true;
            right.receiveShadow = true;
            group.add(right);

            // Ph·∫ßn tr√™n c·ª≠a
            const top = new THREE.Mesh(new THREE.BoxGeometry(dWidth, height - dHeight, thickness), wallMat);
            top.position.set(0, dHeight + (height - dHeight) / 2, 0);
            top.castShadow = true;
            top.receiveShadow = true;
            group.add(top);

            group.position.set(x, y, z);
            group.rotation.y = rotationY;
            scene.add(group);
        }

        function createRoom(centerX, wallMat, floorMat, sideWall = 'right') {
            // Floor
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_WIDTH, ROOM_DEPTH), floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.x = centerX;
            floor.castShadow = true;
            floor.receiveShadow = true;
            scene.add(floor);

            // Back wall (full)
            const backWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_WIDTH, ROOM_HEIGHT), wallMat);
            backWall.position.set(centerX, ROOM_HEIGHT/2, -ROOM_DEPTH/2);
            backWall.castShadow = true;
            backWall.receiveShadow = true;
            scene.add(backWall);

            // Front wall (full)
            const frontWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_WIDTH, ROOM_HEIGHT), wallMat);
            frontWall.position.set(centerX, ROOM_HEIGHT/2, ROOM_DEPTH/2);
            frontWall.castShadow = true;
            frontWall.receiveShadow = true;
            scene.add(frontWall);

            // Side wall (left or right - whichever is not shared with a door)
            if (sideWall === 'left') {
                const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_DEPTH, ROOM_HEIGHT), wallMat);
                leftWall.rotation.y = Math.PI / 2;
                leftWall.position.set(centerX - ROOM_WIDTH/2, ROOM_HEIGHT/2, 0);
                leftWall.castShadow = true;
                leftWall.receiveShadow = true;
                scene.add(leftWall);
            } else if (sideWall === 'right') {
                const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_DEPTH, ROOM_HEIGHT), wallMat);
                rightWall.rotation.y = -Math.PI / 2;
                rightWall.position.set(centerX + ROOM_WIDTH/2, ROOM_HEIGHT/2, 0);
                rightWall.castShadow = true;
                rightWall.receiveShadow = true;
                scene.add(rightWall);
            }

            // Ceiling with sky texture
            const ceilingMat = skyTexture
                ? new THREE.MeshStandardMaterial({
                    map: skyTexture,
                    roughness: 0.7,
                    metalness: 0.2
                })
                : new THREE.MeshStandardMaterial({
                    color: 0x1a1a1a,
                    roughness: 0.9,
                    metalness: 0
                });
            const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_WIDTH, ROOM_DEPTH), ceilingMat);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(centerX, ROOM_HEIGHT, 0);
            ceiling.castShadow = true;
            ceiling.receiveShadow = true;
            scene.add(ceiling);
        }

        function addAllArtworks() {
            if (!ethnicData || ethnicData.length === 0) return;

            ethnicData.forEach(ethnic => {
                const ethnicId = ethnic.id; // 1-54

                // Determine room (18 per room)
                let roomNum, indexInRoom;
                if (ethnicId <= 18) {
                    roomNum = 1;
                    indexInRoom = ethnicId - 1;
                } else if (ethnicId <= 36) {
                    roomNum = 2;
                    indexInRoom = ethnicId - 19;
                } else {
                    roomNum = 3;
                    indexInRoom = ethnicId - 37;
                }

                const centerX = ROOM_CENTERS[roomNum - 1];

                // Arrange paintings per room based on available walls
                // Room 1: Back (6) + Front (6) + Left (6) = 18
                // Room 2: Back (9) + Front (9) = 18 (smaller size to avoid crowding)
                // Room 3: Back (6) + Front (6) + Right (6) = 18
                let x, z, rotY, yPos;
                // Adjust painting sizes per room
                const artW = roomNum === 2 ? 1.5 : 1.6;
                const artH = roomNum === 2 ? 1.2 : 1.3;

                // Default Y position (center height)
                yPos = ROOM_HEIGHT / 2;  // = 4

                // Back wall: indices 0-5 (6 paintings) OR 0-8 (9 paintings for Room 2)
                if (indexInRoom < 6 || (indexInRoom < 9 && roomNum === 2)) {
                    z = -ROOM_DEPTH/2 + 0.15;
                    if (roomNum === 2) {
                        // Room 2: 9 paintings, spacing = 2.5 units, centered on X
                        const backSpacing = 2.5;
                        // Center: total width = (9-1) * 2.5 = 20, so center at centerX
                        x = centerX + ((indexInRoom - 4) * backSpacing);
                    } else {
                        // Room 1/3: 6 paintings, spacing = 2.4 units, moved toward center away from door
                        const backSpacing = 2.4;
                        // Center: total width = (6-1) * 2.4 = 12, centered at centerX
                        x = centerX + ((indexInRoom - 2.5) * backSpacing);
                    }
                    rotY = 0;
                }
                // Front wall: indices 6-11 (6 paintings) OR 9-17 (9 paintings for Room 2)
                else if (indexInRoom < 12 || (indexInRoom < 18 && roomNum === 2)) {
                    z = ROOM_DEPTH/2 - 0.15;
                    if (roomNum === 2) {
                        // Room 2: 9 paintings, spacing = 2.5 units, centered on X
                        const frontSpacing = 2.5;
                        // Center: total width = (9-1) * 2.5 = 20, so center at centerX
                        x = centerX + ((indexInRoom - 13) * frontSpacing);
                    } else {
                        // Room 1/3: 6 paintings, spacing = 2.4 units, moved toward center away from door
                        const frontSpacing = 2.4;
                        // Center: total width = (6-1) * 2.4 = 12, centered at centerX
                        x = centerX + ((indexInRoom - 8.5) * frontSpacing);
                    }
                    rotY = Math.PI;
                }
                // Left/Right wall: indices 12-17 (6 paintings) - ONLY for Room 1 and Room 3
                // These are the walls opposite to the door opening
                else if (indexInRoom >= 12 && indexInRoom < 18) {
                    if (roomNum === 1) {
                        // Left wall (opposite to door): 6 paintings, centered, larger spacing
                        rotY = Math.PI / 2;
                        const leftSpacing = 2.4;
                        // Center Z: total depth = (6-1) * 2.4 = 12, so center at 0, offset = -12/2 = -6
                        z = ((indexInRoom - 12) * leftSpacing) - 6;
                        // X: on left wall, centered with offset to avoid penetrating wall
                        x = centerX - ROOM_WIDTH/2 + 0.8;
                    } else if (roomNum === 3) {
                        // Right wall (opposite to door): 6 paintings, centered, larger spacing
                        rotY = -Math.PI / 2;
                        const rightSpacing = 2.4;
                        // Center Z: total depth = (6-1) * 2.4 = 12, so center at 0, offset = -12/2 = -6
                        z = ((indexInRoom - 12) * rightSpacing) - 6;
                        // X: on right wall, centered with offset to avoid penetrating wall
                        x = centerX + ROOM_WIDTH/2 - 0.8;
                    } else {
                        // Room 2 doesn't have side walls
                        return;
                    }
                } else {
                    // Skip any other cases
                    return;
                }

                addArtPiece(x, yPos, z, rotY, artW, artH, ethnic.name, ethnic.image, ethnic.description);
            });
        }

        function addArtPiece(x, y, z, rotY, w, h, title, imageUrl, desc) {
            const group = new THREE.Group();

            // Frame
            const frameGeo = new THREE.BoxGeometry(w + 0.15, h + 0.15, 0.08);
            const frameMat = new THREE.MeshStandardMaterial({
                color: 0xd4af37,
                roughness: 0.4,
                metalness: 0.8
            });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.receiveShadow = true;
            group.add(frame);

            // Image
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load("/mln131/" + imageUrl, (texture) => {
                const picGeo = new THREE.PlaneGeometry(w, h);
                const picMat = new THREE.MeshStandardMaterial({
                    map: texture,
                    roughness: 0.6
                });
                const pic = new THREE.Mesh(picGeo, picMat);
                pic.position.z = 0.05;
                pic.receiveShadow = true;
                group.add(pic);
            });

            group.position.set(x, y, z);
            group.rotation.y = rotY;
            group.receiveShadow = true;
            scene.add(group);

            objects.push(group);
            artworks.push({ mesh: group, title, description: desc });
        }

        function populateEthnicList() {
            const list = document.getElementById("ethnic-list");
            if (!ethnicData.length) return;

            let html = "";
            ethnicData.forEach(ethnic => {
                const colors = ["#FFD700", "#4CAF50", "#2196F3"];
                const color = colors[ethnic.room - 1];
                html += `<div class="ethnic-item" style="border-color: ${color};" onclick="highlightEthnic(${ethnic.id})">
                    <span style="color: ${color}; font-weight: bold;">${ethnic.id}.</span> ${ethnic.name}
                </div>`;
            });
            list.innerHTML = html;
        }

        function highlightEthnic(id) {
            const ethnic = ethnicData.find(e => e.id === id);
            if (ethnic) {
                teleportToRoom(ethnic.room);
                document.getElementById("art-title").innerText = ethnic.name;
                document.getElementById("art-description").innerText = ethnic.description;
                document.getElementById("info-panel").style.display = "flex";
            }
        }

        function toggleSidebar() {
            const sidebar = document.getElementById("sidebar");
            sidebar.style.display = sidebar.style.display === "none" ? "flex" : "none";
        }

        function closeInfoPanel() {
            document.getElementById("info-panel").style.display = "none";
            activeArtMesh = null;
        }

        function updateScrollHint() {
            const description = document.getElementById("art-description");
            const scrollHint = document.getElementById("scroll-hint");

            // Show hint only if content is scrollable
            if (description.scrollHeight > description.clientHeight) {
                scrollHint.style.display = "block";
                // Reset scroll to top
                description.scrollTop = 0;
            } else {
                scrollHint.style.display = "none";
            }
        }

        function teleportToRoom(roomNum) {
            if (roomNum < 1 || roomNum > 3) return;
            const pos = controls.getObject().position;
            pos.x = ROOM_CENTERS[roomNum - 1];
            pos.y = 1.6;
            pos.z = 0;
            currentRoom = roomNum;
            updateRoomIndicator();
        }

        function updateRoomIndicator() {
            document.getElementById("room-indicator").innerText = `Ph√≤ng: ${currentRoom}/3`;
            document.querySelectorAll(".room-dot").forEach((dot, i) => {
                if (i + 1 === currentRoom) {
                    dot.classList.add("active");
                } else {
                    dot.classList.remove("active");
                }
            });
        }

        function onClick(event) {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(objects, true);

            if (intersects.length > 0) {
                const group = intersects[0].object.parent;
                const art = artworks.find(a => a.mesh === group);
                if (art) {
                    if (activeArtMesh === art.mesh) {
                        closeInfoPanel();
                        return;
                    }
                    document.getElementById("art-title").innerText = art.title;
                    document.getElementById("art-description").innerText = art.description;
                    document.getElementById("info-panel").style.display = "flex";
                    activeArtMesh = art.mesh;
                    // Update scroll hint visibility
                    updateScrollHint();
                }
            }
        }

        function onKeyDown(e) {
            if (!isControlsLocked) return;
            if (e.code === "KeyW" || e.code === "ArrowUp") moveState.forward = true;
            if (e.code === "KeyS" || e.code === "ArrowDown") moveState.backward = true;
            if (e.code === "KeyA" || e.code === "ArrowLeft") moveState.left = true;
            if (e.code === "KeyD" || e.code === "ArrowRight") moveState.right = true;
        }

        function onKeyUp(e) {
            if (e.code === "KeyW" || e.code === "ArrowUp") moveState.forward = false;
            if (e.code === "KeyS" || e.code === "ArrowDown") moveState.backward = false;
            if (e.code === "KeyA" || e.code === "ArrowLeft") moveState.left = false;
            if (e.code === "KeyD" || e.code === "ArrowRight") moveState.right = false;
        }

        function updateMovement(delta) {
            const speed = 8;
            const vel = new THREE.Vector3();

            if (moveState.forward) vel.z += speed;
            if (moveState.backward) vel.z -= speed;
            if (moveState.left) vel.x -= speed;
            if (moveState.right) vel.x += speed;

            controls.moveRight(vel.x * delta);
            controls.moveForward(vel.z * delta);

            const pos = controls.getObject().position;

            // Constrain Z (up-down in room)
            pos.z = Math.max(Z_BOUNDS.min, Math.min(Z_BOUNDS.max, pos.z));

            // Helper function: check if player is in a door zone (can pass through)
            function canPassThroughDoor(doorX, playerX, playerZ) {
                const doorZoneWidth = 2.0;
                const doorZoneDepth = 1.5;
                return Math.abs(playerX - doorX) < doorZoneWidth &&
                       Math.abs(playerZ) <= doorZoneDepth;
            }

            const prevRoom = currentRoom;

            // Simple room detection and boundary enforcement
            // Room 1: X < 9 (DOOR_CENTER_X1)
            if (pos.x < DOOR_CENTER_X1) {
                currentRoom = 1;
                // Enforce left boundary
                pos.x = Math.max(ROOM_BOUNDS[0].minX, pos.x);
                // Allow right boundary only if in door zone
                if (pos.x > ROOM_BOUNDS[0].maxX && !canPassThroughDoor(DOOR_CENTER_X1, pos.x, pos.z)) {
                    pos.x = ROOM_BOUNDS[0].maxX;
                }
            }
            // Room 3: X >= 27 (DOOR_CENTER_X2)
            else if (pos.x >= DOOR_CENTER_X2) {
                currentRoom = 3;
                // Allow left boundary only if in door zone
                if (pos.x < ROOM_BOUNDS[2].minX && !canPassThroughDoor(DOOR_CENTER_X2, pos.x, pos.z)) {
                    pos.x = ROOM_BOUNDS[2].minX;
                }
                // Enforce right boundary
                pos.x = Math.min(ROOM_BOUNDS[2].maxX, pos.x);
            }
            // Room 2: 9 <= X < 27
            else {
                currentRoom = 2;
                // Room 2 can access both doors, no hard boundaries on sides
                // Just ensure player doesn't go too far beyond room bounds
                if (pos.x < ROOM_BOUNDS[1].minX && !canPassThroughDoor(DOOR_CENTER_X1, pos.x, pos.z)) {
                    pos.x = ROOM_BOUNDS[1].minX;
                }
                if (pos.x > ROOM_BOUNDS[1].maxX && !canPassThroughDoor(DOOR_CENTER_X2, pos.x, pos.z)) {
                    pos.x = ROOM_BOUNDS[1].maxX;
                }
            }

            if (currentRoom !== prevRoom) {
                updateRoomIndicator();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (isControlsLocked) {
                updateMovement(delta);
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
